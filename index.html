<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="description"
        content="Axis-level Symmetry Detection with Group-Equivariant Representation for robust and accurate axis-level symmetry detection in complex scenes.">
  <meta name="keywords" content="Symmetry Detection, Group Equivariance, Computer Vision">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Axis-level Symmetry Detection with Group-Equivariant Representation</title>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-PYVRSFMDRL"></script>
  <script>
    window.dataLayer = window.dataLayer || [];

    function gtag() {
      dataLayer.push(arguments);
    }

    gtag('js', new Date());

    gtag('config', 'G-PYVRSFMDRL');
  </script>

  <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro"
        rel="stylesheet">

  <link rel="stylesheet" href="./static/css/bulma.min.css">

  <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <link rel="stylesheet" href="./static/css/index.css">
  <link rel="icon" href="./static/images/favicon.svg">

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>

  <script src="./static/js/index.js"></script>
</head>
<body>

<nav class="navbar" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>
  <div class="navbar-menu">
    <div class="navbar-start" style="flex-grow: 1; justify-content: center;">

    </div>

  </div>
</nav>


<section class="hero" style="padding-top: 2rem;">
  <div class="hero-body" style="padding-top: 1rem;">
    <div class="container is-max-desktop">
      <div class="columns is-centered">
        <div class="column has-text-centered">
          <h1 class="title is-1 publication-title">Axis-level Symmetry Detection with Group-Equivariant Representation</h1>
          <div class="is-size-5 publication-authors">
            <span class="author-block" style="margin-right: 40px;">
              <a href="https://201820894.github.io">Wongyun Yu</a><sup>1</sup></span>
            <span class="author-block" style="margin-right: 40px;">
              <a href="https://ahyunseo.github.io">Ahyun Seo</a><sup>2</sup></span>
            <span class="author-block">
              <a href="https://cvlab.postech.ac.kr/~mcho/">Minsu Cho</a><sup>1,2</sup>
            </span>
          </div>

          <div class="is-size-5 publication-authors">
            <br>
            <span class="author-block"><sup>1</sup>Graduate School of Artificial Intelligence, POSTECH, South Korea</span>
            <br>
            <span class="author-block"><sup>2</sup>Department of Computer Science and Engineering, POSTECH, South Korea</span>
          </div>

          <div class="is-size-6 publication-authors" style="text-align: center; margin: 15px 0;">
            <span class="venue-block">International Conference on Computer Vision (ICCV), 2025</span>
          </div>

          <div class="column has-text-centered">
            <div class="publication-links">
              <!-- arXiv Link. -->
              <span class="link-block">
                <a href="#"
                   class="external-link button is-normal is-rounded is-dark is-disabled">
                  <span class="icon">
                      <i class="ai ai-arxiv"></i>
                  </span>
                  <span>arXiv (Coming Soon)</span>
                </a>
              </span>
              <!-- Code Link. -->
              <span class="link-block">
                <a href="#"
                   class="external-link button is-normal is-rounded is-dark is-disabled">
                  <span class="icon">
                      <i class="fab fa-github"></i>
                  </span>
                  <span>Code (Coming Soon)</span>
                  </a>
              </span>
            </div>

          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<section class="hero teaser" style="padding-bottom: 0.5rem;">
  <div class="container is-max-desktop">
    <div class="hero-body" style="padding-bottom: 0.5rem; padding-top: 0.5rem;">
      <div class="columns is-centered" style="margin-bottom: 5px; margin-top: 2px;">
        <div class="column is-half" style="padding: 0 2px;">
          <div class="has-text-centered">
            <p class="subtitle is-5" style="margin-bottom: 2px; margin-top: 0;"><strong>Ours</strong></p>
            <div id="rotation-viewer-ours" style="text-align: center; margin-bottom: 0; margin-top: 0;">
              <img id="rotation-image-ours" src="./static/images/rotation_ours/000.png" alt="Ours 360-degree rotation demonstration" 
                   style="width: 100%; max-width: 900px; cursor: pointer; margin-top: 0; margin-bottom: 0;">
            </div>
          </div>
        </div>
        <div class="column is-half" style="padding: 0 2px;">
          <div class="has-text-centered">
            <p class="subtitle is-5" style="margin-bottom: 2px; margin-top: 0;"><strong>EquiSym(Coming Soon)</strong></p>
            <div id="rotation-viewer-equisym" style="text-align: center; margin-bottom: 0; margin-top: 0;">
              <img id="rotation-image-equisym" src="./static/images/rotation_equisym/000.png" alt="EquiSym 360-degree rotation demonstration" 
                   style="width: 100%; max-width: 900px; cursor: pointer; margin-top: 0; margin-bottom: 0;">
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>

<div class="has-text-centered" style="margin-top: 10px; font-size: 0.9rem; color: #666;">
  Click to pause/resume • Drag to rotate manually
</div>
<h2 class="subtitle has-text-centered" style="margin-top: 5px; margin-bottom: 0; max-width: 900px; margin-left: auto; margin-right: auto; line-height: 1.5; font-size: 0.9rem;">
  Our method predicts axis-level <b>rotation</b> and <b>reflection symmetries</b> in complex scenes, maintaining consistent detection across different input rotations through <b>group-equivariant representations</b>.
</h2>

<section class="section">
  <div class="container is-max-desktop">
    <!-- Abstract. -->
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Abstract</h2>
        <div class="content has-text-justified">
          <p>
            Symmetry is a fundamental concept that has been studied extensively; however, its detection in complex scenes remains challenging in computer vision. Recent heatmap-based methods identify potential regions of symmetry axes but lack precision for individual axis. In this work, we introduce a novel framework for axis-level detection of the most common symmetry types—reflection and rotation—representing them as explicit geometric primitives <i>i.e.</i>, lines and points.
            We formulate a dihedral group-equivariant dual-branch architecture, where each branch exploits the properties of dihedral group-equivariant features in a novel, specialized manner for each symmetry type. Specifically, for reflection symmetry, we propose <strong>orientational anchors</strong> aligned with group components to enable orientation-specific detection, and <strong>reflectional matching</strong> that computes similarity between patterns and their mirrored counterparts across potential reflection axes.
            For rotational symmetry, we propose <strong>rotational matching</strong> that computes the similarity between patterns at fixed angular intervals. Extensive experiments demonstrate that our method significantly outperforms state-of-the-art methods.
          </p>
        </div>
      </div>
    </div>
    <!--/ Abstract. -->
  </div>
</section>


<section class="section" style="padding-top: 3rem;">
  <div class="container is-max-desktop">
    <div class="columns is-centered has-text-centered">
      <div class="column is-four-fifths">
        <h2 class="title is-3">Method Overview</h2>
        <div class="has-text-centered">
          <img src="./static/images/main_architecture.png" alt="Overall network architecture" style="width: 100%; max-width: 1000px; display: block; margin: 0 auto;">
        </div>
        <div class="content has-text-justified" style="margin-top: 20px;">
          <p>
            Our framework introduces a D<sub>N</sub>-equivariant network for axis-level symmetry detection, modeling reflection axes as line segments and rotation axes as points. The dual-branch architecture uses a dihedral group-equivariant backbone to extract features, then processes them through specialized branches: the reflection branch predicts midpoint, orientation, and length of reflection axes using orientational anchor expansion and reflectional matching, while the rotation branch predicts location and fold class of rotation centers using rotational matching at fixed angular intervals.
          </p>
        </div>
      </div>
    </div>
  </div>
</section>


<section class="section" style="padding-top: 3rem;">
  <div class="container is-max-desktop">

    <div class="columns is-centered">

      <!-- Orientational Anchor Expansion. -->
      <div class="column">
        <div class="content">
          <h2 class="title is-3">Orientational Anchors</h2>
                      <p>
              Inspired by anchor boxes in detection, we treat each pixel as an anchor for potential symmetry axes and introduce <strong>orientational anchors</strong> to integrate the group dimension into the detection framework. This approach enables directionally specialized axis detection and improved handling of axes with overlapping midpoints but different orientations. We aggregate reflection counterpart pairs from D<sub>N</sub>-equivariant features and construct orientational anchors that specialize in detecting axes within specific orientation ranges.
            </p>
                      <div class="has-text-centered" style="margin-top: 50px;">
              <img src="./static/images/orientational_anchor.png" alt="Orientational anchor expansion mechanism" style="width: 100%; max-width: 600px; display: block; margin: 0 auto;">
            </div>
        </div>
      </div>
      <!--/ Orientational Anchor Expansion. -->

      <!-- Symmetry Matching. -->
      <div class="column">
        <h2 class="title is-3">Matching Modules</h2>
        <div class="columns is-centered">
          <div class="column content">
            <p>
              Our framework leverages D<sub>N</sub>-equivariant features for symmetry validation through two specialized matching modules. <strong>Reflectional matching</strong> compares patterns with their mirrored counterparts across different orientations, providing strong cues for reflection symmetry detection. <strong>Rotational matching</strong> compares patterns with their rotated versions at fixed angular separations, exploiting the consistency of feature comparisons to identify rotational symmetries with reduced computational redundancy.
            </p>
                         <div class="has-text-centered">
               <img src="./static/images/matching_module.png" alt="Reflectional and rotational matching modules" style="width: 100%; max-width: 600px; display: block; margin: 0 auto;">
             </div>
          </div>

        </div>
      </div>
    </div>
    <!--/ Symmetry Matching. -->

    <!-- Results. -->
    <div class="columns is-centered" style="margin-top: 3rem;">
      <div class="column is-full-width">
        <h2 class="title is-3">Results</h2>

        <!-- Qualitative Results. -->
        <h3 class="title is-4">Qualitative Evaluation</h3>
        <div class="content has-text-justified">
          <p>
            Our method demonstrates superior performance in detecting both reflection and rotation symmetries across diverse scenes. The results show accurate axis-level detection with robust performance across different object types and scene complexities.
          </p>
        </div>
        <div class="content has-text-centered">
          <img src="./static/images/qualitative_comparison.png" alt="Qualitative comparison with state-of-the-art methods" style="width: 100%; max-width: 1200px; display: block; margin: 0 auto;">
        </div>
        <br/>
        <!--/ Qualitative Results. -->

        <!-- Quantitative Results. -->
        <h3 class="title is-4">Quantitative Evaluation</h3>
        
        <!-- Ablation Studies -->
        <h4 class="title is-5" style="margin-top: 2rem;">Ablation Studies</h4>
        
        <h5 class="title is-6">Reflection Symmetry Detection</h5>
        <table class="academic-table">
          <thead>
            <tr>
              <th class="method-col">Method</th>
              <th colspan="3">Ref. sAP (%)</th>
            </tr>
            <tr class="midrule">
              <th></th>
              <th>@5</th>
              <th>@10</th>
              <th>@15</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="method-col">Axis-level detection</td>
              <td>6.2</td>
              <td>9.3</td>
              <td>11.2</td>
            </tr>
            <tr>
              <td class="method-col">+ Orientational anchors</td>
              <td>16.6</td>
              <td>19.9</td>
              <td>21.1</td>
            </tr>
            <tr>
              <td class="method-col">+ Ref. match<sub>k=0</sub></td>
              <td>17.6</td>
              <td>20.7</td>
              <td>21.8</td>
            </tr>
            <tr>
              <td class="method-col">+ Ref. match<sub>k=0,1</sub></td>
              <td>18.4</td>
              <td>22.0</td>
              <td>23.7</td>
            </tr>
            <tr class="highlight-row">
              <td class="method-col">+ Ref. match<sub>k=0,1,2</sub></td>
              <td><strong>18.8</strong></td>
              <td><strong>22.7</strong></td>
              <td><strong>24.7</strong></td>
            </tr>
          </tbody>
        </table>

        <h5 class="title is-6" style="margin-top: 2rem;">Rotation Symmetry Detection</h5>
        <table class="academic-table">
          <thead>
            <tr>
              <th class="method-col">Method</th>
              <th colspan="3">Center sAP <span class="small-text">(Fold sAP)</span> (%)</th>
            </tr>
            <tr class="midrule">
              <th></th>
              <th>@5</th>
              <th>@10</th>
              <th>@15</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="method-col">Axis-level detection</td>
              <td>31.5 <span class="small-text">(22.5)</span></td>
              <td>34.7 <span class="small-text">(24.6)</span></td>
              <td>35.7 <span class="small-text">(25.3)</span></td>
            </tr>
            <tr>
              <td class="method-col">+ Rot. match<sub>k=0</sub></td>
              <td>35.9 <span class="small-text">(25.4)</span></td>
              <td>37.8 <span class="small-text">(26.6)</span></td>
              <td>37.0 <span class="small-text">(27.2)</span></td>
            </tr>
            <tr>
              <td class="method-col">+ Rot. match<sub>k=0,1</sub></td>
              <td>36.2 <span class="small-text">(26.2)</span></td>
              <td>38.2 <span class="small-text">(27.8)</span></td>
              <td>37.4 <span class="small-text">(28.1)</span></td>
            </tr>
            <tr class="highlight-row">
              <td class="method-col">+ Rot. match<sub>k=0,1,2</sub></td>
              <td><strong>36.8</strong> <span class="small-text">(<strong>26.6</strong>)</span></td>
              <td><strong>39.1</strong> <span class="small-text">(<strong>28.3</strong>)</span></td>
              <td><strong>40.0</strong> <span class="small-text">(<strong>28.9</strong>)</span></td>
            </tr>
          </tbody>
        </table>

        <!-- State-of-the-art Comparison -->
        <h4 class="title is-5" style="margin-top: 3rem;">Comparison with State-of-the-art</h4>
        <table class="academic-table">
          <thead>
            <tr>
              <th class="method-col">Method</th>
              <th colspan="3">Reflection Symmetry</th>
              <th>Rotation Symmetry</th>
            </tr>
            <tr class="midrule">
              <th></th>
              <th>SDRW</th>
              <th>LDRS</th>
              <th>DENDI</th>
              <th>DENDI</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="method-col">PMCNet</td>
              <td><strong>68.8</strong></td>
              <td>37.3</td>
              <td>32.6</td>
              <td>-</td>
            </tr>
            <tr>
              <td class="method-col">EquiSym</td>
              <td>67.5</td>
              <td>40.0</td>
              <td>36.7</td>
              <td>22.4</td>
            </tr>
            <tr class="highlight-row">
              <td class="method-col"><strong>Ours</strong></td>
              <td>68.3</td>
              <td><strong>43.4</strong></td>
              <td><strong>37.2</strong></td>
              <td><strong>26.8</strong></td>
            </tr>
          </tbody>
        </table>

        <!-- Precision-Recall Analysis -->
        <h4 class="title is-5" style="margin-top: 2rem;">Precision-Recall Analysis</h4>
        <div class="content has-text-justified">
          <p>
            Precision-recall curves demonstrate our method's superior performance across multiple datasets. The F1-score vs padding analysis on SDRW shows that our axis-level approach outperforms PMCNet's region-based predictions when evaluation criteria become more stringent, demonstrating more precise axis localization.
          </p>
        </div>
        
        <div class="columns is-multiline" style="margin-bottom: 0;">
          <div class="column is-one-fifth">
            <div class="has-text-centered">
              <p class="subtitle is-6" style="text-align: center; margin-bottom: 0.3rem; margin-left: 32px"><strong>SDRW (Ref.)</strong></p>
              <img src="./static/images/pr_curves_sdrw_ref.png" alt="PR curve for SDRW reflection symmetry" style="width: 100%; max-width: 200px;">
            </div>
          </div>
          <div class="column is-one-fifth">
            <div class="has-text-centered">
              <p class="subtitle is-6" style="text-align: center; margin-bottom: 0.3rem; margin-left: 32px"><strong>LDRS (Ref.)</strong></p>
              <img src="./static/images/pr_curves_ldrs_ref.png" alt="PR curve for LDRS reflection symmetry" style="width: 100%; max-width: 200px;">
            </div>
          </div>
          <div class="column is-one-fifth">
            <div class="has-text-centered">
              <p class="subtitle is-6" style="text-align: center; margin-bottom: 0.3rem; margin-left: 32px"><strong>DENDI (Ref.)</strong></p>
              <img src="./static/images/pr_curves_dendi_ref.png" alt="PR curve for DENDI reflection symmetry" style="width: 100%; max-width: 200px;">
            </div>
          </div>
          <div class="column is-one-fifth">
            <div class="has-text-centered">
              <p class="subtitle is-6" style="text-align: center; margin-bottom: 0.3rem; margin-left: 32px"><strong>DENDI (Rot.)</strong></p>
              <img src="./static/images/pr_curves_dendi_rot.png" alt="PR curve for DENDI rotation symmetry" style="width: 100%; max-width: 200px;">
            </div>
          </div>
          <div class="column is-one-fifth">
            <div class="has-text-centered">
              <p class="subtitle is-6" style="text-align: center; margin-bottom: 0.3rem; margin-left: 32px; margin-top: -20px;"><strong>F1 vs Padding<br/>(LDRS)</strong></p>
              <img src="./static/images/f1_padding_sdrw.png" alt="F1-score vs padding analysis" style="width: 100%; max-width: 200px;">
            </div>
          </div>
        </div>

        <!-- Legend -->
        <div class="has-text-centered" style="margin-top: -0.5rem;">
          <img src="./static/images/legend.png" alt="Legend for PR curves" style="width: auto; max-width: 250px;">
        </div>


        
        <style>
          .academic-table {
            border-collapse: collapse;
            width: 80%;
            max-width: 600px;
            margin: 1rem auto;
            background: white;
            font-size: 0.95rem;
          }
          .academic-table th, .academic-table td {
            padding: 8px 12px;
            text-align: center;
            border: none;
          }
          .academic-table th {
            font-weight: 600;
            border-bottom: 2px solid #333;
            border-top: 2px solid #333;
            text-align: center;
          }
          .academic-table .method-col {
            text-align: left;
            padding-left: 16px;
          }
          .academic-table th.method-col {
            text-align: left;
            padding-left: 16px;
          }
          .academic-table th:not(.method-col) {
            text-align: center;
          }
          .academic-table td:not(.method-col) {
            text-align: center;
          }
          .academic-table tbody tr {
            border-bottom: 1px solid #ddd;
          }
          .academic-table tbody tr:last-child {
            border-bottom: 2px solid #333;
          }
          .academic-table .highlight-row {
            background-color: #f0f0f0;
          }
          .academic-table .midrule {
            border-bottom: 1px solid #333;
          }
          .small-text {
            font-size: 0.85em;
          }
        </style>

        <!--/ Quantitative Results. -->

      </div>
    </div>
    <!--/ Results. -->




  </div>
</section>


<section class="section" id="References" style="padding-top: 3rem;">
  <div class="container is-max-desktop content">
    <h2 class="title">References</h2>
    <div class="content">
      <p>
        <strong>PMCNet:</strong> Ahyun Seo, Woohyeon Shim, Minsu Cho. "Learning to discover reflection symmetry via polar matching convolution." In <em>Proceedings of the IEEE/CVF International Conference on Computer Vision (ICCV)</em>, 2021, pp. 1285-1294.
      </p>
      <p>
        <strong>EquiSym:</strong> Ahyun Seo, Byungjin Kim, Suha Kwak, Minsu Cho. "Reflection and rotation symmetry detection via equivariant learning." In <em>Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition (CVPR)</em>, 2022, pp. 9539-9548.
      </p>
    </div>
  </div>
</section>

<section class="section" id="BibTeX">
  <div class="container is-max-desktop content">
    <h2 class="title">BibTeX</h2>
    <pre><code>@inproceedings{yu2025symdet,
  author    = {Yu, Wongyun and Seo, Ahyun and Cho, Minsu},
  title     = {Axis-level Symmetry Detection with Group-Equivariant Representation},
  booktitle = {International Conference on Computer Vision (ICCV)},
  year      = {2025},
}</code></pre>
  </div>
</section>


<footer class="footer">
  <div class="container">
    <div class="columns is-centered">
      <div class="column is-8">
        <div class="content has-text-centered">
          <p>
            Website template adapted from <a href="https://github.com/nerfies/nerfies.github.io">Nerfies</a>.
          </p>
        </div>
      </div>
    </div>
  </div>
</footer>

  <!-- 360-degree rotation script -->
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      const rotationImageOurs = document.getElementById('rotation-image-ours');
      const rotationImageEquisym = document.getElementById('rotation-image-equisym');
      const totalFrames = 360;
      let currentFrame = 0;
      let isPlaying = true;
      let isDragging = false;
      let isPausedAfterDrag = false; // 드래그 후 정지 상태를 별도로 관리
      let startFrame = 0;
      let animationId;

      // Preload images for smooth playback
      const imagesOurs = [];
      const imagesEquisym = [];
      let loadedImagesOurs = 0;
      let loadedImagesEquisym = 0;
      
      function preloadImages() {
        // Preload Ours images
        for (let i = 0; i < totalFrames; i++) {
          const img = new Image();
          const frameNumber = i.toString().padStart(3, '0');
          img.src = `./static/images/rotation_ours/${frameNumber}.png`;
          img.onload = () => {
            loadedImagesOurs++;
            if (loadedImagesOurs === totalFrames && loadedImagesEquisym === totalFrames) {
              console.log('All images loaded! Starting animation...');
              setPlayingState(true);
              currentFrame = 0;
              updateFrame();
              startAnimation();
            }
          };
          img.onerror = () => {
            console.warn(`Failed to load Ours image: ${frameNumber}.png`);
            loadedImagesOurs++;
            if (loadedImagesOurs === totalFrames && loadedImagesEquisym === totalFrames) {
              setPlayingState(true);
              currentFrame = 0;
              updateFrame();
              startAnimation();
            }
          };
          imagesOurs[i] = img;
        }
        
        // Preload EquiSym images
        for (let i = 0; i < totalFrames; i++) {
          const img = new Image();
          const frameNumber = i.toString().padStart(3, '0');
          img.src = `./static/images/rotation_equisym/${frameNumber}.png`;
          img.onload = () => {
            loadedImagesEquisym++;
            if (loadedImagesOurs === totalFrames && loadedImagesEquisym === totalFrames) {
              setPlayingState(true);
              currentFrame = 0;
              updateFrame();
              startAnimation();
            }
          };
          img.onerror = () => {
            console.warn(`Failed to load EquiSym image: ${frameNumber}.png`);
            loadedImagesEquisym++;
            if (loadedImagesOurs === totalFrames && loadedImagesEquisym === totalFrames) {
              setPlayingState(true);
              currentFrame = 0;
              updateFrame();
              startAnimation();
            }
          };
          imagesEquisym[i] = img;
        }
      }

      function updateFrame() {
        const frameNumber = currentFrame.toString().padStart(3, '0');
        rotationImageOurs.src = `./static/images/rotation_ours/${frameNumber}.png`;
        rotationImageEquisym.src = `./static/images/rotation_equisym/${frameNumber}.png`;
      }

      function animate() {
        // 매 프레임마다 상태 로그 (디버깅용)
        if (currentFrame % 30 === 0) { // 30프레임마다 로그 (0.5초에 한 번)
          console.log('ANIMATE CHECK - frame:', currentFrame, 'isPlaying:', isPlaying, 'isDragging:', isDragging, 'isPausedAfterDrag:', isPausedAfterDrag, 'condition:', isPlaying && !isDragging && !isPausedAfterDrag);
        }
        
        if (isPlaying && !isDragging && !isPausedAfterDrag) {
          currentFrame = (currentFrame + 1) % totalFrames;
          updateFrame();
          if (currentFrame % 60 === 0) { // 60프레임마다 로그 (1초에 한 번)
            console.log('Animation RUNNING - frame:', currentFrame, 'isPlaying:', isPlaying, 'isDragging:', isDragging, 'isPausedAfterDrag:', isPausedAfterDrag);
          }
        } else {
          if (currentFrame % 60 === 0) { // 60프레임마다 로그 (1초에 한 번)
            console.log('Animation PAUSED - frame:', currentFrame, 'isPlaying:', isPlaying, 'isDragging:', isDragging, 'isPausedAfterDrag:', isPausedAfterDrag);
          }
        }
        animationId = requestAnimationFrame(animate);
      }

      function startAnimation() {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        animate();
      }

      // --- 상태 관리 함수 ---
      function setPlayingState(playing) {
        console.log('setPlayingState called with:', playing, 'current isPlaying:', isPlaying, 'current isPausedAfterDrag:', isPausedAfterDrag);
        isPlaying = playing;
        if (isPlaying) {
          isPausedAfterDrag = false; // 재생 시 드래그 후 정지 상태 해제
          rotationImageOurs.style.opacity = '1';
          rotationImageEquisym.style.opacity = '1';
        } else {
          rotationImageOurs.style.opacity = '0.9';
          rotationImageEquisym.style.opacity = '0.9';
          // isPausedAfterDrag는 여기서 변경하지 않음 - 호출자가 관리
        }
        console.log('After setPlayingState, isPlaying is now:', isPlaying, 'isPausedAfterDrag:', isPausedAfterDrag);
      }

      // --- 클릭 이벤트: 토글 ---
      rotationImageOurs.addEventListener('click', function(e) {
        console.log('Ours clicked! Current isPlaying:', isPlaying, 'isPausedAfterDrag:', isPausedAfterDrag, 'ignoreNextClick:', ignoreNextClick);
        if (ignoreNextClick) {
          console.log('Ignoring click after drag');
          ignoreNextClick = false; // 다음 클릭부터는 정상 처리
          e.stopPropagation();
          return;
        }
        
        if (isPausedAfterDrag) {
          // 드래그 후 정지 상태에서는 클릭 시 토글 모드로 전환 (재생 시작)
          console.log('Resuming from drag pause state - starting toggle mode');
          isPlaying = true;
          isPausedAfterDrag = false; // 드래그 후 정지 상태 해제
          rotationImageOurs.style.opacity = '1';
          rotationImageEquisym.style.opacity = '1';
        } else {
          // 일반 상태에서는 토글
          setPlayingState(!isPlaying);
        }
        console.log('After click isPlaying:', isPlaying, 'isPausedAfterDrag:', isPausedAfterDrag);
        e.stopPropagation();
      });
      rotationImageEquisym.addEventListener('click', function(e) {
        console.log('EquiSym clicked! Current isPlaying:', isPlaying, 'isPausedAfterDrag:', isPausedAfterDrag, 'ignoreNextClick:', ignoreNextClick);
        if (ignoreNextClick) {
          console.log('Ignoring click after drag');
          ignoreNextClick = false; // 다음 클릭부터는 정상 처리
          e.stopPropagation();
          return;
        }
        
        if (isPausedAfterDrag) {
          // 드래그 후 정지 상태에서는 클릭 시 토글 모드로 전환 (재생 시작)
          console.log('Resuming from drag pause state - starting toggle mode');
          isPlaying = true;
          isPausedAfterDrag = false; // 드래그 후 정지 상태 해제
          rotationImageOurs.style.opacity = '1';
          rotationImageEquisym.style.opacity = '1';
        } else {
          // 일반 상태에서는 토글
          setPlayingState(!isPlaying);
        }
        console.log('After click isPlaying:', isPlaying, 'isPausedAfterDrag:', isPausedAfterDrag);
        e.stopPropagation();
      });

      // --- 드래그 시작 ---
      let activeDragImage = null;
      let dragStartAngle = 0;
      let dragStartFrame = 0;
      let dragStartX = 0;
      let dragStartY = 0;
      let isDraggingStarted = false;
      let ignoreNextClick = false; // 드래그 후 클릭 무시 플래그
      
      rotationImageOurs.addEventListener('mousedown', function(e) {
        console.log('=== Ours mousedown ===');
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        dragStartFrame = currentFrame;
        activeDragImage = rotationImageOurs;
        const rect = rotationImageOurs.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        dragStartAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
        console.log('Drag start - X:', dragStartX, 'Y:', dragStartY, 'Frame:', dragStartFrame);
        e.preventDefault();
        e.stopPropagation();
      });

      rotationImageEquisym.addEventListener('mousedown', function(e) {
        console.log('=== EquiSym mousedown ===');
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        dragStartFrame = currentFrame;
        activeDragImage = rotationImageEquisym;
        const rect = rotationImageEquisym.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        dragStartAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
        console.log('Drag start - X:', dragStartX, 'Y:', dragStartY, 'Frame:', dragStartFrame);
        e.preventDefault();
        e.stopPropagation();
      });

      document.addEventListener('mousemove', function(e) {
        if (!isDraggingStarted && (dragStartX !== 0 || dragStartY !== 0)) {
          const distance = Math.sqrt((e.clientX - dragStartX) ** 2 + (e.clientY - dragStartY) ** 2);
          if (distance > 5) { // 5픽셀 이상 이동하면 드래그 시작
            console.log('=== Drag started ===');
            console.log('Distance moved:', distance);
            isDragging = true;
            isDraggingStarted = true;
            isPlaying = false; // 직접 설정
            rotationImageOurs.style.opacity = '0.9';
            rotationImageEquisym.style.opacity = '0.9';
            rotationImageOurs.style.cursor = 'grabbing';
            rotationImageEquisym.style.cursor = 'grabbing';
            console.log('Drag started - isDragging:', isDragging, 'isDraggingStarted:', isDraggingStarted);
          }
        }
        
        if (isDragging && isDraggingStarted && activeDragImage) {
          const rect = activeDragImage.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const currentAngle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
          let angleDiff = currentAngle - dragStartAngle;
          if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
          if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
          const degreesDiff = (angleDiff * 180 / Math.PI);
          currentFrame = (dragStartFrame - Math.round(degreesDiff)) % 360;
          if (currentFrame < 0) currentFrame += 360;
          updateFrame();
        }
      });

      document.addEventListener('mouseup', function() {
        console.log('=== Mouseup event ===');
        console.log('isDragging:', isDragging, 'isDraggingStarted:', isDraggingStarted);
        if (isDragging) {
          console.log('=== Drag ended, setting to pause state ===');
          console.log('Before - isPlaying:', isPlaying, 'isPausedAfterDrag:', isPausedAfterDrag);
          isDragging = false;
          isDraggingStarted = false;
          activeDragImage = null;
          isPausedAfterDrag = true; // 드래그 후 정지 상태 설정
          isPlaying = false; // 직접 설정 (setPlayingState 호출하지 않음)
          rotationImageOurs.style.opacity = '0.9';
          rotationImageEquisym.style.opacity = '0.9';
          rotationImageOurs.style.cursor = 'pointer';
          rotationImageEquisym.style.cursor = 'pointer';
          ignoreNextClick = true; // 다음 클릭 이벤트 무시
          console.log('After - isPlaying:', isPlaying, 'isPausedAfterDrag:', isPausedAfterDrag, 'ignoreNextClick:', ignoreNextClick);
        }
        // 드래그 시작 좌표 초기화
        dragStartX = 0;
        dragStartY = 0;
        console.log('=== Mouseup completed ===');
      });

      // --- 터치도 동일하게 ---
      let activeTouchImage = null;
      let touchStartAngle = 0;
      let touchStartFrame = 0;
      rotationImageOurs.addEventListener('touchstart', function(e) {
        isDragging = true;
        activeTouchImage = rotationImageOurs;
        isPlaying = false; // 직접 설정
        rotationImageOurs.style.opacity = '0.9';
        rotationImageEquisym.style.opacity = '0.9';
        const rect = rotationImageOurs.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        touchStartAngle = Math.atan2(e.touches[0].clientY - centerY, e.touches[0].clientX - centerX);
        touchStartFrame = currentFrame;
        e.preventDefault();
        e.stopPropagation();
      });
      rotationImageEquisym.addEventListener('touchstart', function(e) {
        isDragging = true;
        activeTouchImage = rotationImageEquisym;
        isPlaying = false; // 직접 설정
        rotationImageOurs.style.opacity = '0.9';
        rotationImageEquisym.style.opacity = '0.9';
        const rect = rotationImageEquisym.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        touchStartAngle = Math.atan2(e.touches[0].clientY - centerY, e.touches[0].clientX - centerX);
        touchStartFrame = currentFrame;
        e.preventDefault();
        e.stopPropagation();
      });
      document.addEventListener('touchmove', function(e) {
        if (isDragging && activeTouchImage) {
          const rect = activeTouchImage.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const currentAngle = Math.atan2(e.touches[0].clientY - centerY, e.touches[0].clientX - centerX);
          let angleDiff = currentAngle - touchStartAngle;
          if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
          if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
          const degreesDiff = (angleDiff * 180 / Math.PI);
          currentFrame = (touchStartFrame - Math.round(degreesDiff)) % 360;
          if (currentFrame < 0) currentFrame += 360;
          updateFrame();
        }
      });
      document.addEventListener('touchend', function() {
        if (isDragging) {
          console.log('Touch ended, setting to pause state');
          isDragging = false;
          activeTouchImage = null;
          isPausedAfterDrag = true; // 터치 후 정지 상태 설정
          isPlaying = false; // 직접 설정
          rotationImageOurs.style.opacity = '0.9';
          rotationImageEquisym.style.opacity = '0.9';
        }
      });

      // --- 최초 로딩시 ---
      setPlayingState(true);
      
      // Start preloading images
      console.log('Starting image preload...');
      preloadImages();
    });
  </script>

</body>
</html>
